//====================================================================================================================================================
// Copyright 2025 Lake Orion Robotics FIRST Team 302
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//====================================================================================================================================================
// This file was automatically generated by the Team 302 code generator version 20.25.00.05
// Generated on Sunday, February 16, 2025 9:43:58 PM

#include <string>

// FRC Includes
#include <networktables/NetworkTableInstance.h>

#include "DragonTale.h"
#include "utils/PeriodicLooper.h"
#include "state/RobotState.h"

#include "ctre/phoenix6/TalonFX.hpp"
#include "ctre/phoenix6/controls/Follower.hpp"
#include "ctre/phoenix6/configs/Configs.hpp"
#include "ctre/phoenix6/TalonFXS.hpp"
#include "ctre/phoenix6/signals/SpnEnums.hpp"
#include <frc/DigitalInput.h>
#include <frc/filter/Debouncer.h>
#include <ctre/phoenix6/CANcoder.hpp>
#include <ctre/phoenix6/configs/Configurator.hpp>
#include <ctre/phoenix6/signals/SpnEnums.hpp>
#include "mechanisms/DragonTale/InitializeState.h"
#include "mechanisms/DragonTale/ReadyState.h"
#include "mechanisms/DragonTale/HumanPlayerLoadState.h"
#include "mechanisms/DragonTale/GrabAlgaeReefState.h"
#include "mechanisms/DragonTale/HoldState.h"
#include "mechanisms/DragonTale/GrabAlgaeFloorState.h"
#include "mechanisms/DragonTale/ProcessState.h"
#include "mechanisms/DragonTale/NetState.h"
#include "mechanisms/DragonTale/ScoreAlgaeState.h"
#include "mechanisms/DragonTale/L1ScoringPositionState.h"
#include "mechanisms/DragonTale/L2ScoringPositionState.h"
#include "mechanisms/DragonTale/L3ScoringPositionState.h"
#include "mechanisms/DragonTale/L4ScoringPositionState.h"
#include "mechanisms/DragonTale/ScoreCoralState.h"
#include "mechanisms/DragonTale/ManualCoralLoadState.h"
#include "mechanisms/DragonTale/ManualGrabAlgaeReefState.h"
#include "mechanisms/DragonTale/ManualGrabAlgaeFloorState.h"
#include "mechanisms/DragonTale/LaunchNetState.h"
#include "fielddata/DragonTargetFinder.h"
#include "utils/logging/debug/Logger.h"
#include "utils/DragonPower.h"
#include "teleopcontrol/TeleopControl.h"
#include "teleopcontrol/TeleopControlFunctions.h"
#include "utils/AngleUtils.h"
#include "utils/FMSData.h"
#include "tuple"
#include "frc/DataLogManager.h"

using ctre::phoenix6::configs::Slot0Configs;
using ctre::phoenix6::configs::Slot1Configs;
using ctre::phoenix6::configs::TalonFXConfiguration;
using ctre::phoenix6::configs::TalonFXSConfiguration;
using ctre::phoenix6::signals::FeedbackSensorSourceValue;
using ctre::phoenix6::signals::ForwardLimitSourceValue;
using ctre::phoenix6::signals::ForwardLimitTypeValue;
using ctre::phoenix6::signals::GravityTypeValue;
using ctre::phoenix6::signals::InvertedValue;
using ctre::phoenix6::signals::MotorArrangementValue;
using ctre::phoenix6::signals::NeutralModeValue;
using ctre::phoenix6::signals::ReverseLimitSourceValue;
using ctre::phoenix6::signals::ReverseLimitTypeValue;
using ctre::phoenix6::signals::ReverseLimitValue;
using ctre::phoenix6::signals::StaticFeedforwardSignValue;

using std::string;
using std::tuple;
using namespace DragonTaleStates;

void DragonTale::CreateAndRegisterStates()
{
	InitializeState *InitializeStateInst = new InitializeState(string("Initialize"), 0, this, m_activeRobotId);
	AddToStateVector(InitializeStateInst);

	ReadyState *ReadyStateInst = new ReadyState(string("Ready"), 1, this, m_activeRobotId);
	AddToStateVector(ReadyStateInst);

	HumanPlayerLoadState *HumanPlayerLoadStateInst = new HumanPlayerLoadState(string("HumanPlayerLoad"), 2, this, m_activeRobotId);
	AddToStateVector(HumanPlayerLoadStateInst);

	GrabAlgaeReefState *GrabAlgaeReefStateInst = new GrabAlgaeReefState(string("GrabAlgaeReef"), 3, this, m_activeRobotId);
	AddToStateVector(GrabAlgaeReefStateInst);

	HoldState *HoldStateInst = new HoldState(string("Hold"), 4, this, m_activeRobotId);
	AddToStateVector(HoldStateInst);

	GrabAlgaeFloorState *GrabAlgaeFloorStateInst = new GrabAlgaeFloorState(string("GrabAlgaeFloor"), 5, this, m_activeRobotId);
	AddToStateVector(GrabAlgaeFloorStateInst);

	ProcessState *ProcessStateInst = new ProcessState(string("Process"), 6, this, m_activeRobotId);
	AddToStateVector(ProcessStateInst);

	NetState *NetStateInst = new NetState(string("Net"), 7, this, m_activeRobotId);
	AddToStateVector(NetStateInst);

	ScoreAlgaeState *ScoreAlgaeStateInst = new ScoreAlgaeState(string("ScoreAlgae"), 8, this, m_activeRobotId);
	AddToStateVector(ScoreAlgaeStateInst);

	L1ScoringPositionState *L1ScoringPositionStateInst = new L1ScoringPositionState(string("L1ScoringPosition"), 9, this, m_activeRobotId);
	AddToStateVector(L1ScoringPositionStateInst);

	L2ScoringPositionState *L2ScoringPositionStateInst = new L2ScoringPositionState(string("L2ScoringPosition"), 10, this, m_activeRobotId);
	AddToStateVector(L2ScoringPositionStateInst);

	L3ScoringPositionState *L3ScoringPositionStateInst = new L3ScoringPositionState(string("L3ScoringPosition"), 11, this, m_activeRobotId);
	AddToStateVector(L3ScoringPositionStateInst);

	L4ScoringPositionState *L4ScoringPositionStateInst = new L4ScoringPositionState(string("L4ScoringPosition"), 12, this, m_activeRobotId);
	AddToStateVector(L4ScoringPositionStateInst);

	ScoreCoralState *ScoreCoralStateInst = new ScoreCoralState(string("ScoreCoral"), 13, this, m_activeRobotId);
	AddToStateVector(ScoreCoralStateInst);

	ManualCoralLoadState *ManualCoralLoadStateInst = new ManualCoralLoadState(string("ManualCoralLoad"), 14, this, m_activeRobotId);
	AddToStateVector(ManualCoralLoadStateInst);

	ManualGrabAlgaeReefState *ManualGrabAlgaeReefStateInst = new ManualGrabAlgaeReefState(string("ManualGrabAlgaeReef"), 15, this, m_activeRobotId);
	AddToStateVector(ManualGrabAlgaeReefStateInst);

	ManualGrabAlgaeFloorState *ManualGrabAlgaeFloorStateInst = new ManualGrabAlgaeFloorState(string("ManualGrabAlgaeFloor"), 16, this, m_activeRobotId);
	AddToStateVector(ManualGrabAlgaeFloorStateInst);

	LaunchNetState *LaunchNetStateInst = new LaunchNetState(string("LaunchNet"), 17, this, m_activeRobotId);
	AddToStateVector(LaunchNetStateInst);

	InitializeStateInst->RegisterTransitionState(ReadyStateInst);
	ReadyStateInst->RegisterTransitionState(HumanPlayerLoadStateInst);
	ReadyStateInst->RegisterTransitionState(GrabAlgaeReefStateInst);
	ReadyStateInst->RegisterTransitionState(GrabAlgaeFloorStateInst);
	ReadyStateInst->RegisterTransitionState(ProcessStateInst);
	ReadyStateInst->RegisterTransitionState(NetStateInst);
	ReadyStateInst->RegisterTransitionState(L1ScoringPositionStateInst);
	ReadyStateInst->RegisterTransitionState(L2ScoringPositionStateInst);
	ReadyStateInst->RegisterTransitionState(L3ScoringPositionStateInst);
	ReadyStateInst->RegisterTransitionState(L4ScoringPositionStateInst);
	HumanPlayerLoadStateInst->RegisterTransitionState(ReadyStateInst);
	HumanPlayerLoadStateInst->RegisterTransitionState(GrabAlgaeReefStateInst);
	HumanPlayerLoadStateInst->RegisterTransitionState(HoldStateInst);
	HumanPlayerLoadStateInst->RegisterTransitionState(GrabAlgaeFloorStateInst);
	GrabAlgaeReefStateInst->RegisterTransitionState(ReadyStateInst);
	GrabAlgaeReefStateInst->RegisterTransitionState(HumanPlayerLoadStateInst);
	GrabAlgaeReefStateInst->RegisterTransitionState(HoldStateInst);
	GrabAlgaeReefStateInst->RegisterTransitionState(GrabAlgaeFloorStateInst);
	HoldStateInst->RegisterTransitionState(ReadyStateInst);
	HoldStateInst->RegisterTransitionState(HumanPlayerLoadStateInst);
	HoldStateInst->RegisterTransitionState(GrabAlgaeReefStateInst);
	HoldStateInst->RegisterTransitionState(GrabAlgaeFloorStateInst);
	HoldStateInst->RegisterTransitionState(ProcessStateInst);
	HoldStateInst->RegisterTransitionState(NetStateInst);
	HoldStateInst->RegisterTransitionState(L1ScoringPositionStateInst);
	HoldStateInst->RegisterTransitionState(L2ScoringPositionStateInst);
	HoldStateInst->RegisterTransitionState(L3ScoringPositionStateInst);
	HoldStateInst->RegisterTransitionState(L4ScoringPositionStateInst);
	GrabAlgaeFloorStateInst->RegisterTransitionState(ReadyStateInst);
	GrabAlgaeFloorStateInst->RegisterTransitionState(GrabAlgaeReefStateInst);
	GrabAlgaeFloorStateInst->RegisterTransitionState(HoldStateInst);
	ProcessStateInst->RegisterTransitionState(ReadyStateInst);
	ProcessStateInst->RegisterTransitionState(HoldStateInst);
	ProcessStateInst->RegisterTransitionState(NetStateInst);
	ProcessStateInst->RegisterTransitionState(ScoreAlgaeStateInst);
	NetStateInst->RegisterTransitionState(ReadyStateInst);
	NetStateInst->RegisterTransitionState(HoldStateInst);
	NetStateInst->RegisterTransitionState(ProcessStateInst);
	NetStateInst->RegisterTransitionState(ScoreAlgaeStateInst);
	NetStateInst->RegisterTransitionState(L2ScoringPositionStateInst);
	NetStateInst->RegisterTransitionState(L3ScoringPositionStateInst);
	NetStateInst->RegisterTransitionState(L4ScoringPositionStateInst);
	ScoreAlgaeStateInst->RegisterTransitionState(ReadyStateInst);
	ScoreAlgaeStateInst->RegisterTransitionState(HoldStateInst);
	L1ScoringPositionStateInst->RegisterTransitionState(ReadyStateInst);
	L1ScoringPositionStateInst->RegisterTransitionState(HoldStateInst);
	L1ScoringPositionStateInst->RegisterTransitionState(L2ScoringPositionStateInst);
	L1ScoringPositionStateInst->RegisterTransitionState(L3ScoringPositionStateInst);
	L1ScoringPositionStateInst->RegisterTransitionState(L4ScoringPositionStateInst);
	L1ScoringPositionStateInst->RegisterTransitionState(ScoreCoralStateInst);
	L2ScoringPositionStateInst->RegisterTransitionState(ReadyStateInst);
	L2ScoringPositionStateInst->RegisterTransitionState(HoldStateInst);
	L2ScoringPositionStateInst->RegisterTransitionState(GrabAlgaeReefStateInst);
	L2ScoringPositionStateInst->RegisterTransitionState(L3ScoringPositionStateInst);
	L2ScoringPositionStateInst->RegisterTransitionState(L4ScoringPositionStateInst);
	L2ScoringPositionStateInst->RegisterTransitionState(ScoreCoralStateInst);
	L2ScoringPositionStateInst->RegisterTransitionState(ProcessStateInst);
	L2ScoringPositionStateInst->RegisterTransitionState(NetStateInst);
	L3ScoringPositionStateInst->RegisterTransitionState(ReadyStateInst);
	L3ScoringPositionStateInst->RegisterTransitionState(HoldStateInst);
	L3ScoringPositionStateInst->RegisterTransitionState(GrabAlgaeReefStateInst);
	L3ScoringPositionStateInst->RegisterTransitionState(L2ScoringPositionStateInst);
	L3ScoringPositionStateInst->RegisterTransitionState(L4ScoringPositionStateInst);
	L3ScoringPositionStateInst->RegisterTransitionState(ScoreCoralStateInst);
	L3ScoringPositionStateInst->RegisterTransitionState(NetStateInst);
	L3ScoringPositionStateInst->RegisterTransitionState(ProcessStateInst);
	L4ScoringPositionStateInst->RegisterTransitionState(ReadyStateInst);
	L4ScoringPositionStateInst->RegisterTransitionState(HoldStateInst);
	L4ScoringPositionStateInst->RegisterTransitionState(GrabAlgaeReefStateInst);
	L4ScoringPositionStateInst->RegisterTransitionState(L2ScoringPositionStateInst);
	L4ScoringPositionStateInst->RegisterTransitionState(L3ScoringPositionStateInst);
	L4ScoringPositionStateInst->RegisterTransitionState(ScoreCoralStateInst);
	L4ScoringPositionStateInst->RegisterTransitionState(NetStateInst);
	L4ScoringPositionStateInst->RegisterTransitionState(ProcessStateInst);
	ScoreCoralStateInst->RegisterTransitionState(ReadyStateInst);
	ScoreCoralStateInst->RegisterTransitionState(GrabAlgaeReefStateInst);
	ScoreCoralStateInst->RegisterTransitionState(HoldStateInst);
	ManualCoralLoadStateInst->RegisterTransitionState(ReadyStateInst);
	ManualCoralLoadStateInst->RegisterTransitionState(L1ScoringPositionStateInst);
	ManualCoralLoadStateInst->RegisterTransitionState(L2ScoringPositionStateInst);
	ManualCoralLoadStateInst->RegisterTransitionState(L3ScoringPositionStateInst);
	ManualCoralLoadStateInst->RegisterTransitionState(L4ScoringPositionStateInst);
	ManualCoralLoadStateInst->RegisterTransitionState(ManualGrabAlgaeReefStateInst);
	ManualGrabAlgaeReefStateInst->RegisterTransitionState(ReadyStateInst);
	ManualGrabAlgaeReefStateInst->RegisterTransitionState(ProcessStateInst);
	ManualGrabAlgaeReefStateInst->RegisterTransitionState(NetStateInst);
	ManualGrabAlgaeReefStateInst->RegisterTransitionState(ManualCoralLoadStateInst);
	ManualGrabAlgaeReefStateInst->RegisterTransitionState(ManualGrabAlgaeFloorStateInst);
	ManualGrabAlgaeFloorStateInst->RegisterTransitionState(ReadyStateInst);
	ManualGrabAlgaeFloorStateInst->RegisterTransitionState(ProcessStateInst);
	ManualGrabAlgaeFloorStateInst->RegisterTransitionState(NetStateInst);
	ManualGrabAlgaeFloorStateInst->RegisterTransitionState(ManualCoralLoadStateInst);
	ManualGrabAlgaeFloorStateInst->RegisterTransitionState(ManualGrabAlgaeReefStateInst);
	LaunchNetStateInst->RegisterTransitionState(ReadyStateInst);
	LaunchNetStateInst->RegisterTransitionState(HoldStateInst);
	LaunchNetStateInst->RegisterTransitionState(ProcessStateInst);
	LaunchNetStateInst->RegisterTransitionState(ScoreAlgaeStateInst);
	LaunchNetStateInst->RegisterTransitionState(L2ScoringPositionStateInst);
	LaunchNetStateInst->RegisterTransitionState(L3ScoringPositionStateInst);
	LaunchNetStateInst->RegisterTransitionState(L4ScoringPositionStateInst);
}

DragonTale::DragonTale(RobotIdentifier activeRobotId) : BaseMech(MechanismTypes::MECHANISM_TYPE::DRAGON_TALE, std::string("DragonTale")),
														m_activeRobotId(activeRobotId),
														m_stateMap()
{
	m_scoringMode = RobotStateChanges::ScoringMode::Coral;
	RobotState *m_robotState = RobotState::GetInstance();

	m_robotState->RegisterForStateChanges(this, RobotStateChanges::StateChange::DesiredScoringMode_Int);
	m_robotState->RegisterForStateChanges(this, RobotStateChanges::StateChange::GameState_Int);
	m_robotState->RegisterForStateChanges(this, RobotStateChanges::StateChange::ClimbModeStatus_Int);
	m_robotState->RegisterForStateChanges(this, RobotStateChanges::StateChange::IsInBargeZone_Bool);
	m_robotState->RegisterForStateChanges(this, RobotStateChanges::StateChange::IsInReefZone_Bool);
	m_robotState->RegisterForStateChanges(this, RobotStateChanges::StateChange::DriveToFieldElementIsDone_Bool);

	PeriodicLooper::GetInstance()->RegisterAll(this);
}

std::map<std::string, DragonTale::STATE_NAMES> DragonTale::stringToSTATE_NAMESEnumMap{
	{"STATE_INITIALIZE", DragonTale::STATE_NAMES::STATE_INITIALIZE},
	{"STATE_READY", DragonTale::STATE_NAMES::STATE_READY},
	{"STATE_HUMAN_PLAYER_LOAD", DragonTale::STATE_NAMES::STATE_HUMAN_PLAYER_LOAD},
	{"STATE_GRAB_ALGAE_REEF", DragonTale::STATE_NAMES::STATE_GRAB_ALGAE_REEF},
	{"STATE_HOLD", DragonTale::STATE_NAMES::STATE_HOLD},
	{"STATE_GRAB_ALGAE_FLOOR", DragonTale::STATE_NAMES::STATE_GRAB_ALGAE_FLOOR},
	{"STATE_PROCESS", DragonTale::STATE_NAMES::STATE_PROCESS},
	{"STATE_NET", DragonTale::STATE_NAMES::STATE_NET},
	{"STATE_SCORE_ALGAE", DragonTale::STATE_NAMES::STATE_SCORE_ALGAE},
	{"STATE_L1SCORING_POSITION", DragonTale::STATE_NAMES::STATE_L1SCORING_POSITION},
	{"STATE_L2SCORING_POSITION", DragonTale::STATE_NAMES::STATE_L2SCORING_POSITION},
	{"STATE_L3SCORING_POSITION", DragonTale::STATE_NAMES::STATE_L3SCORING_POSITION},
	{"STATE_L4SCORING_POSITION", DragonTale::STATE_NAMES::STATE_L4SCORING_POSITION},
	{"STATE_SCORE_CORAL", DragonTale::STATE_NAMES::STATE_SCORE_CORAL},
	{"STATE_MANUAL_CORAL_LOAD", DragonTale::STATE_NAMES::STATE_MANUAL_CORAL_LOAD},
	{"STATE_MANUAL_GRAB_ALGAE_REEF", DragonTale::STATE_NAMES::STATE_MANUAL_GRAB_ALGAE_REEF},
	{"STATE_MANUAL_GRAB_ALGAE_FLOOR", DragonTale::STATE_NAMES::STATE_MANUAL_GRAB_ALGAE_FLOOR},
	{"STATE_LAUNCH_NET", DragonTale::STATE_NAMES::STATE_LAUNCH_NET},

};

void DragonTale::CreatePRACTICE_BOT9999()
{
	m_ntName = "DragonTale";
	m_Arm = new ctre::phoenix6::hardware::TalonFX(17, "rio");
	m_ElevatorLeader = new ctre::phoenix6::hardware::TalonFX(4, "canivore");
	m_AlgaeTalonFX = new ctre::phoenix6::hardware::TalonFX(19, "rio");
	m_ElevatorFollower = new ctre::phoenix6::hardware::TalonFX(16, "canivore");
	m_Coral = new ctre::phoenix6::hardware::TalonFXS(18, "rio");

	m_BranchCANRange = nullptr;
	m_ElevatorCANRange = nullptr;

	ctre::phoenix6::configs::CANcoderConfiguration ArmAngleSensorConfigs{};
	ArmAngleSensorConfigs.MagnetSensor.MagnetOffset = units::angle::turn_t(0.421387);
	ArmAngleSensorConfigs.MagnetSensor.SensorDirection = ctre::phoenix6::signals::SensorDirectionValue::Clockwise_Positive;
	m_ArmAngleSensor = new ctre::phoenix6::hardware::CANcoder(17, "rio");
	m_ArmAngleSensor->GetConfigurator().Apply(ArmAngleSensorConfigs);
	ctre::phoenix6::configs::CANcoderConfiguration ElevatorHeightSensorConfigs{};
	ElevatorHeightSensorConfigs.MagnetSensor.MagnetOffset = units::angle::turn_t(-0.15673828125);
	ElevatorHeightSensorConfigs.MagnetSensor.SensorDirection = ctre::phoenix6::signals::SensorDirectionValue::CounterClockwise_Positive;
	m_ElevatorHeightSensor = new ctre::phoenix6::hardware::CANcoder(4, "canivore");
	m_ElevatorHeightSensor->GetConfigurator().Apply(ElevatorHeightSensorConfigs);

	m_PositionInch = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_INCH,		  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PositionInch",								  // std::string indentifier
		2.5,											  // double proportional
		0.35,											  // double integral
		0,												  // double derivative
		0.3,											  // double feedforward
		0.3,											  // double velocityGain
		0.05,											  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE,					 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		true,													 // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);
	m_PositionDegree = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_DEGREES,	  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PositionDegree",								  // std::string indentifier
		57,												  // double proportional
		25,												  // double integral
		5,												  // double derivative
		1.8,											  // double feedforward
		0.75,											  // double velocityGain
		0.25,											  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE,					 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		true,													 // bool enableFOC
		ControlData::GravityTypeValue::Arm_Cosine,				 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);
	m_PercentOutput = new ControlData(
		ControlModes::CONTROL_TYPE::PERCENT_OUTPUT,		  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PercentOutput",								  // std::string indentifier
		0,												  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE,					 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		false,													 // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);

	ReadConstants("DragonTale.xml", 9999);
}

void DragonTale::CreateCOMP_BOT302()
{
	m_ntName = "DragonTale";
	m_Arm = new ctre::phoenix6::hardware::TalonFX(17, "canivore");
	m_ElevatorLeader = new ctre::phoenix6::hardware::TalonFX(4, "canivore");
	m_ElevatorFollower = new ctre::phoenix6::hardware::TalonFX(16, "canivore");
	m_Coral = new ctre::phoenix6::hardware::TalonFXS(18, "canivore");
	m_AlgaeTalonFXS = new ctre::phoenix6::hardware::TalonFXS(19, "canivore");

	m_ArmSensors = new ctre::phoenix6::hardware::CANdi(2, "canivore");
	m_ElevatorCANRange = new ctre::phoenix6::hardware::CANrange(31, "canivore");
	m_BranchCANRange = new ctre::phoenix6::hardware::CANrange(32, "canivore");

	ctre::phoenix6::configs::CANcoderConfiguration ArmAngleSensorConfigs{};
	ArmAngleSensorConfigs.MagnetSensor.MagnetOffset = units::angle::turn_t(-0.031738);
	ArmAngleSensorConfigs.MagnetSensor.SensorDirection = ctre::phoenix6::signals::SensorDirectionValue::CounterClockwise_Positive;
	m_ArmAngleSensor = new ctre::phoenix6::hardware::CANcoder(17, "canivore");
	m_ArmAngleSensor->GetConfigurator().Apply(ArmAngleSensorConfigs);
	ctre::phoenix6::configs::CANcoderConfiguration ElevatorHeightSensorConfigs{};
	ElevatorHeightSensorConfigs.MagnetSensor.MagnetOffset = units::angle::turn_t(-0.11962890625);
	ElevatorHeightSensorConfigs.MagnetSensor.SensorDirection = ctre::phoenix6::signals::SensorDirectionValue::CounterClockwise_Positive;
	m_ElevatorHeightSensor = new ctre::phoenix6::hardware::CANcoder(4, "canivore");
	m_ElevatorHeightSensor->GetConfigurator().Apply(ElevatorHeightSensorConfigs);

	ctre::phoenix6::configs::CANrangeConfiguration BranchCANRangeConfigs{};
	BranchCANRangeConfigs.ProximityParams.ProximityThreshold = 15.0_in;
	BranchCANRangeConfigs.FovParams.FOVRangeX = 15.0_deg;
	BranchCANRangeConfigs.FovParams.FOVRangeY = 10.0_deg;
	BranchCANRangeConfigs.ProximityParams.MinSignalStrengthForValidMeasurement = units::dimensionless::scalar_t(700.0);

	m_BranchCANRange->GetConfigurator().Apply(BranchCANRangeConfigs);

	ctre::phoenix6::configs::CANrangeConfiguration ElevatorCANRangeConfigs{};
	ElevatorCANRangeConfigs.FovParams.FOVRangeX = 3.75_deg;
	ElevatorCANRangeConfigs.FovParams.FOVRangeY = 3.75_deg;
	m_ElevatorCANRange->GetConfigurator().Apply(ElevatorCANRangeConfigs);

	ctre::phoenix6::configs::CANdiConfiguration ArmSensorsConfigs{};
	ArmSensorsConfigs.DigitalInputs.S1CloseState = ctre::phoenix6::signals::S1CloseStateValue::CloseWhenHigh;
	ArmSensorsConfigs.DigitalInputs.S1CloseState = ctre::phoenix6::signals::S1CloseStateValue::CloseWhenHigh;

	m_ArmSensors->GetConfigurator().Apply(ArmSensorsConfigs);

	m_PositionInch = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_INCH,		  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PositionInch",								  // std::string indentifier
		2.5,											  // double proportional
		0.35,											  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		0.3,											  // double velocityGain
		0.05,											  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE,					 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		true,													 // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);
	m_PositionDegree = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_DEGREES,	  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PositionDegree",								  // std::string indentifier
		57,												  // double proportional
		25,												  // double integral
		0,												  // double derivative
		1.8,											  // double feedforward
		0.75,											  // double velocityGain
		0.25,											  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE,					 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		true,													 // bool enableFOC
		ControlData::GravityTypeValue::Arm_Cosine,				 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);
	m_PercentOutput = new ControlData(
		ControlModes::CONTROL_TYPE::PERCENT_OUTPUT,		  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PercentOutput",								  // std::string indentifier
		0,												  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE,					 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		false,													 // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);

	ReadConstants("DragonTale.xml", 302);
}

void DragonTale::InitializePRACTICE_BOT9999()
{
	InitializeTalonFXArmPRACTICE_BOT9999();
	InitializeTalonFXElevatorLeaderPRACTICE_BOT9999();
	InitializeTalonFXAlgaePRACTICE_BOT9999();
	InitializeTalonFXElevatorFollowerPRACTICE_BOT9999();
	InitializeTalonFXSCoralPRACTICE_BOT9999();
}

void DragonTale::InitializeCOMP_BOT302()
{
	InitializeTalonFXArmCOMP_BOT302();
	InitializeTalonFXElevatorLeaderCOMP_BOT302();
	InitializeTalonFXElevatorFollowerCOMP_BOT302();
	InitializeTalonFXSCoralCOMP_BOT302();
	InitializeTalonFXSAlgaeCOMP_BOT302();
}
void DragonTale::InitializeTalonFXArmPRACTICE_BOT9999()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(120);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(70);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(35);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.25);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);
	configs.HardwareLimitSwitch.ForwardLimitEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);

	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::Clockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.MotionMagic.MotionMagicCruiseVelocity = units::angular_velocity::turns_per_second_t(75);
	configs.MotionMagic.MotionMagicAcceleration = units::angular_acceleration::turns_per_second_squared_t(100);
	configs.MotionMagic.MotionMagicJerk = units::angular_jerk::radians_per_second_cubed_t(0);
	configs.Feedback.FeedbackRemoteSensorID = 17;
	configs.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::FusedCANcoder;
	configs.Feedback.SensorToMechanismRatio = 1;
	configs.Feedback.RotorToSensorRatio = 240;

	configs.Slot0.kP = m_PositionDegree->GetP();
	configs.Slot0.kI = m_PositionDegree->GetI();
	configs.Slot0.kD = m_PositionDegree->GetD();
	configs.Slot0.kG = m_PositionDegree->GetF();
	configs.Slot0.kS = m_PositionDegree->GetS();
	configs.Slot0.kV = m_PositionDegree->GetV();
	configs.Slot0.kA = m_PositionDegree->GetA();
	configs.Slot0.GravityType = m_PositionDegree->GetGravityType();
	configs.Slot0.StaticFeedforwardSign = m_PositionDegree->GetStaticFeedforwardSign();

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_Arm->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_Arm", "m_Arm Status", status.GetName());

	m_ArmPositionDegree.EnableFOC = m_PositionDegree->IsFOCEnabled();
}

void DragonTale::InitializeTalonFXElevatorLeaderPRACTICE_BOT9999()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(0);
	configs.CurrentLimits.StatorCurrentLimitEnable = false;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(50);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.25);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);

	configs.HardwareLimitSwitch.ForwardLimitEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::turn_t(m_maxHeight.value());
	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Feedback.FeedbackRemoteSensorID = 4;
	configs.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::RemoteCANcoder;
	configs.Feedback.SensorToMechanismRatio = 0.108878152421;

	m_elevatorDiameterInch = 0.75;
	m_elevatorGearRatio = 3.0;
	configs.MotionMagic.MotionMagicCruiseVelocity = units::angular_velocity::turns_per_second_t(100);
	configs.MotionMagic.MotionMagicAcceleration = units::angular_acceleration::turns_per_second_squared_t(75);
	configs.MotionMagic.MotionMagicJerk = units::angular_jerk::radians_per_second_cubed_t(0);
	configs.MotionMagic.MotionMagicExpo_kV = ctre::unit::volts_per_turn_per_second_t(0.2);
	configs.MotionMagic.MotionMagicExpo_kA = ctre::unit::volts_per_turn_per_second_squared_t(0.15);

	configs.Slot0.kP = m_PositionInch->GetP();
	configs.Slot0.kI = m_PositionInch->GetI();
	configs.Slot0.kD = m_PositionInch->GetD();
	configs.Slot0.kG = m_PositionInch->GetF();
	configs.Slot0.kS = m_PositionInch->GetS();
	configs.Slot0.kV = m_PositionInch->GetV();
	configs.Slot0.kA = m_PositionInch->GetA();
	configs.Slot0.GravityType = m_PositionInch->GetGravityType();
	configs.Slot0.StaticFeedforwardSign = m_PositionInch->GetStaticFeedforwardSign();

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_ElevatorLeader->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_ElevatorLeader", "m_ElevatorLeader Status", status.GetName());
	m_ElevatorLeaderPositionInch.EnableFOC = m_PositionInch->IsFOCEnabled();
}

void DragonTale::InitializeTalonFXAlgaePRACTICE_BOT9999()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(0);
	configs.CurrentLimits.StatorCurrentLimitEnable = false;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(70);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(35);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.5);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.OpenLoopRamps.VoltageOpenLoopRampPeriod = units::time::second_t(0.25);
	configs.HardwareLimitSwitch.ForwardLimitEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);

	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::RotorSensor;
	configs.Feedback.SensorToMechanismRatio = 1;

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_AlgaeTalonFX->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_AlgaeTalonFX", "m_AlgaeTalonFX Status", status.GetName());
}

void DragonTale::InitializeTalonFXElevatorFollowerPRACTICE_BOT9999()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(0);
	configs.CurrentLimits.StatorCurrentLimitEnable = false;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(50);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.25);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);
	configs.HardwareLimitSwitch.ForwardLimitEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(m_maxHeight.value());

	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::Clockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_ElevatorFollower->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_ElevatorFollower", "m_ElevatorFollower Status", status.GetName());

	m_ElevatorFollower->SetControl(ctre::phoenix6::controls::StrictFollower{4});
}

void DragonTale::InitializeTalonFXSCoralPRACTICE_BOT9999()
{
	TalonFXSConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(60);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.2);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.OpenLoopRamps.VoltageOpenLoopRampPeriod = units::time::second_t(0.25);
	configs.HardwareLimitSwitch.ForwardLimitEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);

	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Commutation.MotorArrangement = MotorArrangementValue::Minion_JST;

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_Coral->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_Coral", "m_Coral Status", status.GetName());
}

void DragonTale::InitializeTalonFXArmCOMP_BOT302()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(120);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(70);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(35);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.25);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);

	configs.HardwareLimitSwitch.ForwardLimitEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::Disabled; // Verify S1/S2
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::Disabled; // Verify S1/S2
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::Clockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.MotionMagic.MotionMagicCruiseVelocity = units::angular_velocity::turns_per_second_t(850);
	configs.MotionMagic.MotionMagicAcceleration = units::angular_acceleration::turns_per_second_squared_t(1000);
	configs.MotionMagic.MotionMagicJerk = units::angular_jerk::radians_per_second_cubed_t(0);
	configs.MotionMagic.MotionMagicExpo_kV = ctre::unit::volts_per_turn_per_second_t(0.05);
	configs.MotionMagic.MotionMagicExpo_kA = ctre::unit::volts_per_turn_per_second_squared_t(0.08);
	configs.Feedback.FeedbackRemoteSensorID = 17;
	configs.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::FusedCANcoder;
	configs.Feedback.SensorToMechanismRatio = 1;
	configs.Feedback.RotorToSensorRatio = 180;

	configs.Slot0.kP = m_PositionDegree->GetP();
	configs.Slot0.kI = m_PositionDegree->GetI();
	configs.Slot0.kD = m_PositionDegree->GetD();
	configs.Slot0.kG = m_PositionDegree->GetF();
	configs.Slot0.kS = m_PositionDegree->GetS();
	configs.Slot0.kV = m_PositionDegree->GetV();
	configs.Slot0.kA = m_PositionDegree->GetA();
	configs.Slot0.GravityType = m_PositionDegree->GetGravityType();
	configs.Slot0.StaticFeedforwardSign = m_PositionDegree->GetStaticFeedforwardSign();

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_Arm->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_Arm", "m_Arm Status", status.GetName());

	m_ArmPositionDegree.EnableFOC = m_PositionDegree->IsFOCEnabled();
}

void DragonTale::InitializeTalonFXElevatorLeaderCOMP_BOT302()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(120);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(70);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(35);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.25);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);

	configs.HardwareLimitSwitch.ForwardLimitEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 1;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::turn_t(m_maxHeight.value()); //(m_maxHeight / (units::length::inch_t(0.75))).value() * 3 / std::numbers::pi
	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::RemoteCANdiS1;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 1;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::RemoteCANdiS2;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.MotionMagic.MotionMagicCruiseVelocity = units::angular_velocity::turns_per_second_t(200);
	configs.MotionMagic.MotionMagicAcceleration = units::angular_acceleration::turns_per_second_squared_t(300);
	configs.MotionMagic.MotionMagicJerk = units::angular_jerk::radians_per_second_cubed_t(0);
	configs.MotionMagic.MotionMagicExpo_kV = ctre::unit::volts_per_turn_per_second_t(0.08);
	configs.MotionMagic.MotionMagicExpo_kA = ctre::unit::volts_per_turn_per_second_squared_t(0.1);

	configs.Feedback.FeedbackRemoteSensorID = 4;
	configs.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::RemoteCANcoder;
	configs.Feedback.SensorToMechanismRatio = 0.134535;

	m_elevatorDiameterInch = 0.75;
	m_elevatorGearRatio = 4.0;

	configs.Slot0.kP = m_PositionInch->GetP();
	configs.Slot0.kI = m_PositionInch->GetI();
	configs.Slot0.kD = m_PositionInch->GetD();
	configs.Slot0.kG = m_PositionInch->GetF();
	configs.Slot0.kS = m_PositionInch->GetS();
	configs.Slot0.kV = m_PositionInch->GetV();
	configs.Slot0.kA = m_PositionInch->GetA();
	configs.Slot0.GravityType = m_PositionInch->GetGravityType();
	configs.Slot0.StaticFeedforwardSign = m_PositionInch->GetStaticFeedforwardSign();

	m_elevatorFeedForwardVoltage = units::voltage::volt_t(m_PositionInch->GetF());
	m_elevatorKP = m_PositionInch->GetP();
	m_elevatorKI = m_PositionInch->GetI();
	m_elevatorKD = m_PositionInch->GetD();

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_ElevatorLeader->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_ElevatorLeader", "m_ElevatorLeader Status", status.GetName());
	m_ElevatorLeaderPositionInch.EnableFOC = m_PositionInch->IsFOCEnabled();
}

void DragonTale::InitializeTalonFXElevatorFollowerCOMP_BOT302()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(120);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(70);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(35);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.25);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);

	configs.HardwareLimitSwitch.ForwardLimitEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 1;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::turn_t(m_maxHeight.value()); //(m_maxHeight / (units::length::inch_t(0.75))).value() * 3 / std::numbers::pi
	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::RemoteCANdiS1;				  // Verify S1/S2
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 1;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::RemoteCANdiS2; // Verify S1/S2
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::Clockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_ElevatorFollower->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_ElevatorFollower", "m_ElevatorFollower Status", status.GetName());

	m_ElevatorFollower->SetControl(ctre::phoenix6::controls::StrictFollower{4});
}

void DragonTale::InitializeTalonFXSCoralCOMP_BOT302()
{
	TalonFXSConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(100);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(60);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.2);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.OpenLoopRamps.VoltageOpenLoopRampPeriod = units::time::second_t(0.2);

	configs.HardwareLimitSwitch.ForwardLimitEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::Clockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Commutation.MotorArrangement = MotorArrangementValue::Minion_JST;

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_Coral->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_CoralTalonFXS", "m_CoralTalonFXS Status", status.GetName());
}

void DragonTale::InitializeTalonFXSAlgaeCOMP_BOT302()
{
	TalonFXSConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(100);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(60);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.2);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.OpenLoopRamps.VoltageOpenLoopRampPeriod = units::time::second_t(0.25);
	configs.HardwareLimitSwitch.ForwardLimitEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);

	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Commutation.MotorArrangement = MotorArrangementValue::Minion_JST;

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_AlgaeTalonFXS->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_AlgaeTalonFXS", "m_AlgaeTalonFXS Status", status.GetName());
}

void DragonTale::SetCurrentState(int state, bool run)
{
	StateMgr::SetCurrentState(state, run);
}

void DragonTale::RunCommonTasks()
{
	if ((m_ElevatorLeader->GetReverseLimit().GetValue() == ReverseLimitValue::ClosedToGround) && (units::math::abs(GetElevatorHeight()) > 1_in))
	{
		m_ElevatorHeightSensor->SetPosition(0_tr, 5_ms);
	}

	UpdateTarget();
	IsElevatorInSync();
	SetAlgaeMotor();
	Cyclic();

	LogInformation();
	RobotState::GetInstance()->PublishStateChange(RobotStateChanges::StateChange::ElevatorHeight_Inch, units::length::meter_t(GetElevatorHeight()));
}

/// @brief  Set the control constants (e.g. PIDF values).
/// @param [in] ControlData*                                   pid:  the control constants
/// @return void
void DragonTale::SetControlConstants(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, int slot, ControlData pid)
{
}

/// @brief update the output to the mechanism using the current controller and target value(s)
/// @return void
void DragonTale::Update()
{
	m_Arm->SetControl(*m_ArmActiveTarget);
	m_Coral->SetControl(*m_CoralActiveTarget);

	m_ElevatorLeader->SetControl(*m_ElevatorLeaderActiveTarget);

	if (m_activeRobotId == RobotIdentifier::PRACTICE_BOT_9999)
	{
		m_AlgaeTalonFX->SetControl(*m_AlgaeTalonFXActiveTarget);
	}
	else
	{
		m_AlgaeTalonFXS->SetControl(*m_AlgaeTalonFXSActiveTarget);
	}
}

bool DragonTale::IsAtMinPosition(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier) const
{
	// auto motor = GetMotorMech(identifier);
	// if (motor != nullptr)
	// {
	//     return motor->IsAtMinTravel();
	// }
	return false;
}

bool DragonTale::IsAtMaxPosition(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier) const
{
	// auto motor = GetMotorMech(identifier);
	// if (motor != nullptr)
	// {
	//     return motor->IsAtMaxTravel();
	// }
	return false;
}

void DragonTale::Cyclic()
{
	Update();
}
ControlData *DragonTale::GetControlData(string name)
{
	if (name.compare("PositionInch") == 0)
		return m_PositionInch;
	if (name.compare("PositionDegree") == 0)
		return m_PositionDegree;
	if (name.compare("PercentOutput") == 0)
		return m_PercentOutput;

	return nullptr;
}
/*==================================================================================================================

Hand-Coded Things are here :)

===================================================================================================================*/
void DragonTale::NotifyStateUpdate(RobotStateChanges::StateChange change, int value)
{
	if (RobotStateChanges::StateChange::DesiredScoringMode_Int == change)
		m_scoringMode = static_cast<RobotStateChanges::ScoringMode>(value);

	else if (RobotStateChanges::StateChange::GameState_Int == change)
		m_gameMode = static_cast<RobotStateChanges::GamePeriod>(value);
}

void DragonTale::NotifyStateUpdate(RobotStateChanges::StateChange change, bool value)
{
	if (RobotStateChanges::StateChange::IsInReefZone_Bool == change)
		m_isInReefZone = value;

	else if (RobotStateChanges::StateChange::IsInBargeZone_Bool == change)
		m_isInBargeZone = value;

	else if (RobotStateChanges::StateChange::DriveToFieldElementIsDone_Bool == change)
		m_isDriveToIsDone = value;
}

void DragonTale::SetSensorFailSafe()
{
	if (TeleopControl::GetInstance()->IsButtonPressed(TeleopControlFunctions::MANUAL_ON))
	{
		m_manualMode = true;
	}
	else if (TeleopControl::GetInstance()->IsButtonPressed(TeleopControlFunctions::MANUAL_OFF))
	{
		m_manualMode = false;
	}
}

void DragonTale::SetAlgaeReefPosition()
{
	bool isBlue = FMSData::GetAllianceColor() == frc::DriverStation::Alliance::kBlue;

	units::length::inch_t algeHeight = isBlue ? m_grabAlgaeLow : m_grabAlgaeHigh;
	units::angle::degree_t algeAngle = isBlue ? m_grabAlgaeLowAngle : m_grabAlgaeHighAngle;
	// Adjust the angle to the nearest 60-degree increment
	auto info = (DragonTargetFinder::GetInstance()->GetPose(DragonTargetFinderTarget::CLOSEST_REEF_ALGAE));
	if (info)
	{
		frc::Pose2d algaePose = std::get<frc::Pose2d>(info.value());

		int closestMultiple = static_cast<int>((algaePose.Rotation().Degrees() + 180.5_deg).value());

		int multipleNumber = closestMultiple / 60;

		if (multipleNumber % 2 == 0)
		{
			algeHeight = isBlue ? m_grabAlgaeHigh : m_grabAlgaeLow;
			algeAngle = isBlue ? m_grabAlgaeHighAngle : m_grabAlgaeLowAngle;
		}
	}

	if (m_prevAlgaeHeight != algeHeight)
	{
		SetElevatorTarget(algeHeight);
		SetArmTarget(algeAngle);
	}

	m_prevAlgaeHeight = algeHeight;

	if (TeleopControl::GetInstance()->IsButtonPressed(TeleopControlFunctions::ALGAE_HIGH))
	{
		SetElevatorTarget(m_grabAlgaeHigh);
		SetArmTarget(m_grabAlgaeHighAngle);
	}
	else if (TeleopControl::GetInstance()->IsButtonPressed(TeleopControlFunctions::ALGAE_LOW))
	{
		SetElevatorTarget(m_grabAlgaeLow);
		SetArmTarget(m_grabAlgaeLowAngle);
	}
}

void DragonTale::UpdateTarget()
{
	units::angle::degree_t actualTargetAngle = m_armTarget;
	units::length::inch_t actualTargetHeight = m_elevatorTarget;
	units::length::inch_t elevatorError = units::math::abs(m_elevatorTarget - GetElevatorHeight());

	double elevatorInput = TeleopControl::GetInstance()->GetAxisValue(TeleopControlFunctions::ELAVATOR);
	double armInput = TeleopControl::GetInstance()->GetAxisValue(TeleopControlFunctions::ARM);

	if (elevatorError > m_elevatorErrorThreshold)
	{
		actualTargetAngle = m_armHoldAngle;
	}
	else if (GetElevatorHeight() < m_elevatorProtectionHeight && m_armTarget < m_armProtectionAngle)
	{
		actualTargetAngle = m_armProtectionAngle;
	}

	m_armLoggingTarget = actualTargetAngle.value();
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "Arm Angle Target", m_armLoggingTarget);
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "Elevator Target", actualTargetHeight.value());

	if ((abs(armInput) > m_manualControlThreshold))
	{
		UpdateTargetArmPercentOutput(armInput * m_changeRate);
		units::angle::degree_t armAngle = GetArmAngle();
		SetArmTarget(armAngle);
		m_armLoggingTarget = armAngle.value();
	}
	else
		UpdateTargetArmPositionDegree(actualTargetAngle);

	// units::voltage::volt_t elevatorPIDOutput{m_elevatorController.Calculate(GetElevatorCANRangeHeight(), actualTargetHeight)};
	if (abs(elevatorInput) > m_manualControlThreshold || m_elevatorRemedialAction)
	{
		UpdateTargetElevatorLeaderPercentOutput(elevatorInput * m_changeRate);
		SetElevatorTarget(GetElevatorHeight());
	}
	else
		UpdateTargetElevatorLeaderPositionInch(actualTargetHeight);
	// UpdateTargetElevatorLeaderVoltage(elevatorPIDOutput);
}

bool DragonTale::AtTarget()
{
	return ((units::math::abs(m_elevatorTarget - GetElevatorHeight()) < m_elevatorAtTargetThreshold) && (units::math::abs(m_armTarget - GetArmAngle()) < m_ArmAtTargetThreshold));
}

void DragonTale::IsElevatorInSync()
{
	double motorCounts = m_ElevatorLeader->GetRotorPosition().GetValueAsDouble();
	double elevatorCount = (motorCounts / (m_elevatorGearRatio)) * m_elevatorDiameterInch * std::numbers::pi;

	m_motorCountInches = units::length::inch_t(elevatorCount);

	if (m_motorCountInches <= units::length::inch_t(-10))
	{
		m_elevatorRemedialAction = true;
	}

	if (m_elevatorRemedialAction)
	{
		if (m_ElevatorLeader->GetReverseLimit().GetValue() == ReverseLimitValue::ClosedToGround)
		{
			m_elevatorRemedialAction = false;
		}
	}
}

void DragonTale::SetAlgaeMotor()
{
	if ((GetAlgaeSensorState() || GetManualMode()) && (GetCurrentState() != STATE_SCORE_ALGAE))
	{
		if (m_activeRobotId == RobotIdentifier::PRACTICE_BOT_9999)
			UpdateTargetAlgaeTalonFXPercentOutput(0.05);
		else
			UpdateTargetAlgaeTalonFXSPercentOutput(0.05);
	}
}

void DragonTale::DataLog(uint64_t timestamp)
{
	LogArm("/DragonTale/Arm/Angle", timestamp, "Degrees", GetArmAngle().value());
	LogArmTarget("/DragonTale/Arm/Target", timestamp, "double", m_armLoggingTarget);
	LogElevatorLeader("/DragonTale/Elevator/ElevatorLeaderHeight", timestamp, "inches", GetElevatorHeight().value());
	LogElevatorLeaderTarget("/DragonTale/Elevator/ElevatorLeaderTarget", timestamp, "double", m_elevatorTarget.value());
	LogElevatorFollower("/DragonTale/Elevator/ElevatorFollower", timestamp, "inches", units::length::inch_t(m_ElevatorFollower->GetPosition().GetValueAsDouble()).value());
	LogElevatorFollowerTarget("/DragonTale/Elevator/ElevatorFollowerTarget", timestamp, "double", m_ElevatorLeader->GetRotorPosition().GetValueAsDouble());
	LogCoralOutSensor("/DragonTale/Coral/CoralOutSensor", timestamp, GetCoralOutSensorState());
	LogAlgaeSensor("/DragonTale/Algae/ALgaeSensor", timestamp, GetAlgaeSensorState());
	LogDragonTaleState("/DragonTale/DragonTaleState", timestamp, GetCurrentState());
}

void DragonTale::LogInformation()
{
	// TODO: Remove this logging once we have datalogging and have both robots in a swell condition :)
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "Coral Out Sensor", GetCoralOutSensorState());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "Algae Sensor", GetAlgaeSensorState());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "Arm Angle Method (Abs)", GetArmAngle().value());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "Elevator Height Method", GetElevatorHeight().value());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "State", GetCurrentState());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "DriveToIsDone", m_isDriveToIsDone);
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "At Target", AtTarget());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "IsInBargeZone", m_isInBargeZone);
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "IsInReefZone", m_isInReefZone);
}