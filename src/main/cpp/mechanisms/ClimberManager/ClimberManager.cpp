//====================================================================================================================================================
// Copyright 2025 Lake Orion Robotics FIRST Team 302
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//====================================================================================================================================================
// This file was automatically generated by the Team 302 code generator version 20.25.00.05
// Generated on Sunday, February 16, 2025 7:41:53 PM

#include <string>

// FRC Includes
#include <networktables/NetworkTableInstance.h>

#include "ClimberManager.h"
#include "utils/logging/debug/Logger.h"
#include "utils/PeriodicLooper.h"
#include "state/RobotState.h"
#include "utils/DragonPower.h"

#include "ctre/phoenix6/TalonFX.hpp"
#include "ctre/phoenix6/TalonFXS.hpp"
#include "ctre/phoenix6/controls/Follower.hpp"
#include "ctre/phoenix6/configs/Configs.hpp"
#include "mechanisms/ClimberManager/InitState.h"
#include "mechanisms/ClimberManager/OffState.h"
#include "mechanisms/ClimberManager/ClimbState.h"
#include "mechanisms/ClimberManager/DeliverState.h"
#include "state/RobotState.h"

#include "frc/DataLogManager.h"

using ctre::phoenix6::configs::Slot0Configs;
using ctre::phoenix6::configs::Slot1Configs;
using ctre::phoenix6::configs::TalonFXConfiguration;
using ctre::phoenix6::configs::TalonFXSConfiguration;
using ctre::phoenix6::signals::FeedbackSensorSourceValue;
using ctre::phoenix6::signals::ForwardLimitSourceValue;
using ctre::phoenix6::signals::ForwardLimitTypeValue;
using ctre::phoenix6::signals::GravityTypeValue;
using ctre::phoenix6::signals::InvertedValue;
using ctre::phoenix6::signals::MotorArrangementValue;
using ctre::phoenix6::signals::NeutralModeValue;
using ctre::phoenix6::signals::ReverseLimitSourceValue;
using ctre::phoenix6::signals::ReverseLimitTypeValue;
using ctre::phoenix6::signals::StaticFeedforwardSignValue;

using std::string;
using namespace ClimberManagerStates;

void ClimberManager::CreateAndRegisterStates()
{
	InitState *InitStateInst = new InitState(string("Init"), 0, this, m_activeRobotId);
	AddToStateVector(InitStateInst);

	OffState *OffStateInst = new OffState(string("Off"), 1, this, m_activeRobotId);
	AddToStateVector(OffStateInst);

	ClimbState *ClimbStateInst = new ClimbState(string("Climb"), 2, this, m_activeRobotId);
	AddToStateVector(ClimbStateInst);

	DeliverState *DeliverClimberStateInst = new DeliverState(string("DeliverClimber"), 3, this, m_activeRobotId);
	AddToStateVector(DeliverClimberStateInst);

	InitStateInst->RegisterTransitionState(OffStateInst);
	OffStateInst->RegisterTransitionState(DeliverClimberStateInst);
	ClimbStateInst->RegisterTransitionState(OffStateInst);
	DeliverClimberStateInst->RegisterTransitionState(OffStateInst);
	DeliverClimberStateInst->RegisterTransitionState(ClimbStateInst);
}

ClimberManager::ClimberManager(RobotIdentifier activeRobotId) : BaseMech(MechanismTypes::MECHANISM_TYPE::CLIMBER_MANAGER, std::string("ClimberManager")),
																m_activeRobotId(activeRobotId),
																m_stateMap(),
																m_climbMode(RobotStateChanges::ClimbMode::ClimbModeOff)
{
	PeriodicLooper::GetInstance()->RegisterAll(this);
	RobotState::GetInstance()->RegisterForStateChanges(this, RobotStateChanges::StateChange::ClimbModeStatus_Int);
	RobotState::GetInstance()->RegisterForStateChanges(this, RobotStateChanges::StateChange::GameState_Int);
}

std::map<std::string, ClimberManager::STATE_NAMES> ClimberManager::stringToSTATE_NAMESEnumMap{
	{"STATE_INIT", ClimberManager::STATE_NAMES::STATE_INIT},
	{"STATE_OFF", ClimberManager::STATE_NAMES::STATE_OFF},
	{"STATE_CLIMB", ClimberManager::STATE_NAMES::STATE_CLIMB},
	{"STATE_DELIVER_CLIMBER", ClimberManager::STATE_NAMES::STATE_DELIVER_CLIMBER},
};

void ClimberManager::CreatePRACTICE_BOT9999()
{
	m_ntName = "ClimberManager";
	m_Climber = new ctre::phoenix6::hardware::TalonFX(7, "canivore");

	m_PositionDegree = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_DEGREES,	  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PositionDegree",								  // std::string indentifier
		1,												  // double proportional
		0,												  // double integral
		0.1,											  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE,					 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		true,													 // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);
	m_PercentOut = new ControlData(
		ControlModes::CONTROL_TYPE::PERCENT_OUTPUT,		  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PercentOut",									  // std::string indentifier
		0,												  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE,					 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		false,													 // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);
	m_PositionDegreeUp = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_DEGREES,	  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PositionDegreeUp",							  // std::string indentifier
		1,												  // double proportional
		0,												  // double integral
		0.1,											  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE,					 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		true,													 // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);

	ReadConstants("ClimberManager.xml", 9999);
}

void ClimberManager::CreateCOMP_BOT302()
{
	m_ntName = "ClimberManager";
	m_Climber = new ctre::phoenix6::hardware::TalonFX(7, "canivore");

	m_PositionDegree = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_DEGREES,	  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PositionDegree",								  // std::string indentifier
		1,												  // double proportional
		0,												  // double integral
		0.1,											  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE,					 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		true,													 // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);
	m_PercentOut = new ControlData(
		ControlModes::CONTROL_TYPE::PERCENT_OUTPUT,		  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PercentOut",									  // std::string indentifier
		0,												  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE,					 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		false,													 // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);
	m_PositionDegreeUp = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_DEGREES,	  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PositionDegreeUp",							  // std::string indentifier
		1,												  // double proportional
		0,												  // double integral
		0.1,											  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE,					 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		true,													 // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);

	ReadConstants("ClimberManager.xml", 302);
}

void ClimberManager::InitializePRACTICE_BOT9999()
{
	InitializeTalonFXClimberPRACTICE_BOT9999();
}

void ClimberManager::InitializeCOMP_BOT302()
{
	InitializeTalonFXClimberCOMP_BOT302();
}
void ClimberManager::InitializeTalonFXClimberPRACTICE_BOT9999()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(0);
	configs.CurrentLimits.StatorCurrentLimitEnable = false;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(70);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(35);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.25);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);
	configs.HardwareLimitSwitch.ForwardLimitEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);

	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::RotorSensor;
	configs.Feedback.SensorToMechanismRatio = 1.0495;

	configs.Slot0.kP = m_PositionDegree->GetP();
	configs.Slot0.kI = m_PositionDegree->GetI();
	configs.Slot0.kD = m_PositionDegree->GetD();
	configs.Slot0.kG = m_PositionDegree->GetF();
	configs.Slot0.kS = m_PositionDegree->GetS();
	configs.Slot0.kV = m_PositionDegree->GetV();
	configs.Slot0.kA = m_PositionDegree->GetA();
	configs.Slot0.GravityType = m_PositionDegree->GetGravityType();
	configs.Slot0.StaticFeedforwardSign = m_PositionDegree->GetStaticFeedforwardSign();

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_Climber->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_Climber", "m_Climber Status", status.GetName());
}
void ClimberManager::InitializeTalonFXClimberCOMP_BOT302()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(0);
	configs.CurrentLimits.StatorCurrentLimitEnable = false;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(70);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.25);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);
	configs.HardwareLimitSwitch.ForwardLimitEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);

	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::RotorSensor;
	configs.Feedback.SensorToMechanismRatio = 1.0495;

	configs.Slot0.kP = m_PositionDegree->GetP();
	configs.Slot0.kI = m_PositionDegree->GetI();
	configs.Slot0.kD = m_PositionDegree->GetD();
	configs.Slot0.kG = m_PositionDegree->GetF();
	configs.Slot0.kS = m_PositionDegree->GetS();
	configs.Slot0.kV = m_PositionDegree->GetV();
	configs.Slot0.kA = m_PositionDegree->GetA();
	configs.Slot0.GravityType = m_PositionDegree->GetGravityType();
	configs.Slot0.StaticFeedforwardSign = m_PositionDegree->GetStaticFeedforwardSign();

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_Climber->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_Climber", "m_Climber Status", status.GetName());
}

void ClimberManager::SetCurrentState(int state, bool run)
{
	StateMgr::SetCurrentState(state, run);
}

void ClimberManager::RunCommonTasks()
{
	// This function is called once per loop before the current state Run()
	Cyclic();
}

/// @brief  Set the control constants (e.g. PIDF values).
/// @param [in] ControlData*                                   pid:  the control constants
/// @return void
void ClimberManager::SetControlConstants(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, int slot, ControlData pid)
{
}

/// @brief update the output to the mechanism using the current controller and target value(s)
/// @return void
void ClimberManager::Update()
{
	m_Climber->SetControl(*m_ClimberActiveTarget);
}

void ClimberManager::Cyclic()
{
	Update();

	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "Climber", "Climber Position", m_Climber->GetPosition().GetValueAsDouble());
}

void ClimberManager::NotifyStateUpdate(RobotStateChanges::StateChange statechange, int value)
{
	if (statechange == RobotStateChanges::StateChange::ClimbModeStatus_Int)
	{
		m_climbMode = static_cast<RobotStateChanges::ClimbMode>(value);
	}
	else if (statechange == RobotStateChanges::StateChange::GameState_Int)
	{
		m_gameMode = static_cast<RobotStateChanges::GamePeriod>(value);
	}
}

bool ClimberManager::AtTarget()
{
	return units::math::abs(m_ClimberPositionDegree.Position - m_Climber->GetPosition().GetValue()) < m_climberThreshold;
}

ControlData *ClimberManager::GetControlData(string name)
{
	if (name.compare("PositionDegree") == 0)
		return m_PositionDegree;
	if (name.compare("PercentOut") == 0)
		return m_PercentOut;
	if (name.compare("PositionDegreeUp") == 0)
		return m_PositionDegreeUp;

	return nullptr;
}

void ClimberManager::DataLog(uint64_t timestamp)
{
	// auto currTime = m_powerTimer.Get();

	// LogClimber(std::string("Climber/PositionDegrees"), std::string("Degrees"), m_Climber->GetPosition().GetValueAsDouble());
	// LogClimberTarget(std::string("Climber/TargetPositionDegrees"), std::string("Degrees"), m_ClimberPositionDegree.Position.value());
	// auto ClimberPower = DragonPower::CalcPowerEnergy(currTime, m_Climber->GetSupplyVoltage().GetValueAsDouble(), m_Climber->GetSupplyCurrent().GetValueAsDouble());
	// m_power = get<0>(ClimberPower);
	// m_energy = get<1>(ClimberPower);
	// m_totalEnergy += m_energy;
	// LogClimberPower(std::string("Climber/Power"), std::string("Amps"), m_power);
	// LogClimberEnergy(std::string("Climber/Energy"), std::string("Watts"), m_energy);

	// LogClimberManagerState(std::string("Climber/ClimberManagerState"), std::string("int"), GetCurrentState());

	// m_totalWattHours += DragonPower::ConvertEnergyToWattHours(m_totalEnergy);
	// LogClimberManagerTotalEnergy(std::string("Climber/TotalEnergy"), std::string("Watts"), m_totalEnergy);
	// LogClimberManagerTotalWattHours(std::string("Climber/TotalWattHours"), std::string("WattHours"), m_totalWattHours);
	// m_powerTimer.Reset();
	// m_powerTimer.Start();
}